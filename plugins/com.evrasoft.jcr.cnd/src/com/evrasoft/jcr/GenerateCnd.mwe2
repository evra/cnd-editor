module com.evrasoft.jcr.GenerateCnd

import org.eclipse.emf.mwe.utils.*
import org.eclipse.xtext.generator.*
import org.eclipse.xtext.ui.generator.*


var fileExtensions = "cnd"
var projectName = "com.evrasoft.jcr.cnd"

var grammarURI = "platform:/resource/${projectName}/src/com/evrasoft/jcr/Cnd.xtext"
var runtimeProject = "../${projectName}"
var generateXtendStub = true

Workflow {
    bean = StandaloneSetup {
    	
        // use an XtextResourceset throughout the process, which is able to resolve classpath:/ URIs.
        resourceSet = org.eclipse.xtext.resource.XtextResourceSet:theResourceSet {}
        
        // add mappings from platform:/resource to classpath:/
        uriMap = {
            from = "platform:/resource/org.eclipse.xtext.xbase/"
            to = "classpath:/"
        }
        uriMap = {
            from = "platform:/resource/org.eclipse.xtext.common.types/"
            to = "classpath:/"
        }
        
        // register current projects and its siblings for platform URI map, as they are not on the classpath.
        platformUri = "${runtimeProject}/.."
        // The following two lines can be removed, if Xbase is not used.
        registerGeneratedEPackage = "org.eclipse.xtext.xbase.XbasePackage"
        registerGenModelFile = "platform:/resource/org.eclipse.xtext.xbase/model/Xbase.genmodel"

    }
    
    component = DirectoryCleaner {
    	directory = "${runtimeProject}/src-gen"
    }
    
    component = DirectoryCleaner {
        directory = "${runtimeProject}/model"
    }

    component = DirectoryCleaner {
    	directory = "${runtimeProject}.ui/src-gen"
    }
    
    component = DirectoryCleaner {
    	directory = "../../tests/${projectName}.tests/src-gen"
    }
    
    component = Generator auto-inject {
    	pathRtProject = runtimeProject
    	pathUiProject = "${runtimeProject}.ui"
    	pathTestProject = "../../tests/${projectName}.tests"
    	projectNameRt = projectName
    	projectNameUi = "${projectName}.ui"
    	
    	language = auto-inject {
            // make sure we use the resourceSet created during standalone setup.
            forcedResourceSet = theResourceSet
            
            uri = grammarURI
    
            // Java API to access grammar elements (required by several other fragments)
            fragment = grammarAccess.GrammarAccessFragment auto-inject {}
    
            // generates Java API for the generated EPackages
        	fragment = ecore.EMFGeneratorFragment auto-inject {
                    javaModelDirectory = "/${projectName}/src-gen"
                    emfRuntimeVersion = "2.10"
            }
    
            // the old serialization component
            // fragment = parseTreeConstructor.ParseTreeConstructorFragment auto-inject {}    
    
            // serializer 2.0
            fragment = serializer.SerializerFragment auto-inject {
                generateStub = false
            }
    
            // a custom ResourceFactory for use with EMF
            fragment = resourceFactory.ResourceFactoryFragment auto-inject {
            	fileExtensions = fileExtensions
            }
    
//            // The antlr parser generator fragment.
//            fragment = parser.antlr.XtextAntlrGeneratorFragment auto-inject {
//                // For the very slow servers
//                antlrParam = "-Xconversiontimeout" antlrParam = "5000"
//            }
    
    		//make language case insansitive
            fragment = org.eclipse.xtext.generator.parser.antlr.ex.rt.AntlrGeneratorFragment {
              options = {
                  ignoreCase = true
              }
            }
        	//make language case insansitive
//      		fragment = org.eclipse.xtext.generator.parser.antlr.ex.ca.ContentAssistParserGeneratorFragment{
//            	options = {
//            		ignoreCase = true
//            	}
//            }
    
    
            // Xtend-based API for validation
            fragment = validation.ValidatorFragment auto-inject {
            //    composedCheck = "org.eclipse.xtext.validation.ImportUriValidator"
            //    composedCheck = "org.eclipse.xtext.validation.NamesAreUniqueValidator"
            }
    		
    		//2.8
//    		fragment = validation.JavaValidatorFragment {
//				composedCheck = "org.eclipse.xtext.validation.NamesAreUniqueValidator"
//			}
    
       
            // scoping and exporting API
            fragment = scoping.ImportNamespacesScopingFragment auto-inject {
                ignoreCase = true
            }
            fragment = exporting.QualifiedNamesFragment auto-inject {}
            fragment = builder.BuilderIntegrationFragment auto-inject {}
    
            // generator API
            fragment = generator.GeneratorFragment auto-inject {}
    
            // formatter API
            fragment = formatting.FormatterFragment auto-inject {}
            //2.8
            //fragment = formatting2.Formatter2Fragment {}
            
    
            // labeling API
            fragment = labeling.LabelProviderFragment auto-inject {}
    
            // outline API
            fragment = outline.OutlineTreeProviderFragment auto-inject {}
            fragment = outline.QuickOutlineFragment auto-inject {}
    
            // quickfix API
            fragment = quickfix.QuickfixProviderFragment auto-inject {}
    
            // content assist API
            fragment = contentAssist.ContentAssistFragment auto-inject {}
            
            //2.8
            //fragment = contentAssist.JavaBasedContentAssistFragment {}
    
            // generates a more lightweight Antlr parser and lexer tailored for content assist
            fragment = parser.antlr.XtextAntlrUiGeneratorFragment auto-inject {
            	//2.8
            	partialParsing = true
            }
    
            // generates junit test support classes into Generator#pathTestProject
            fragment = junit.Junit4Fragment auto-inject {}
    
            // rename refactoring
            fragment = refactoring.RefactorElementNameFragment auto-inject {}
    
            // provides the necessary bindings for java types integration
            fragment = types.TypesGeneratorFragment auto-inject {}
    
            // generates the required bindings only if the grammar inherits from Xbase
            fragment = xbase.XbaseGeneratorFragment auto-inject {}
    
            // provides a preference page for template proposals
            fragment = templates.CodetemplatesGeneratorFragment auto-inject {}
    
            // provides a compare view
            fragment = compare.CompareFragment auto-inject {
            	fileExtensions = fileExtensions
            }
        }
    }
}

